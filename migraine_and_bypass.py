# -*- coding: utf-8 -*-
"""Migraine and Bypass.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FvBl2E7GvAvbIQtO2Upq_CLmk9_PgzTA
"""

import pandas as pd
from scipy.stats import wilcoxon, ttest_rel, shapiro
import numpy as np
import matplotlib.pyplot as plt

# Load the datasets
before_data = pd.read_csv('Before_Data.csv')
after_data = pd.read_csv('After_Data.csv')

# Calculate Paired Differences
differences = {
    'Weight': after_data['Weight'] - before_data['Weight'],
    'BMI': after_data['BMI'] - before_data['BMI'],
    'Severity': after_data['Severity'] - before_data['Severity'],
    'Frequency': after_data['Frequency'] - before_data['Frequency'],
    'MIDAS': after_data['MIDAS'] - before_data['MIDAS'],
    'MSQ': after_data['MSQ'] - before_data['MSQ']
}

diff_df = pd.DataFrame(differences)

# Test for Normality using Shapiro-Wilk Test
normality_results = {}
for column in diff_df.columns:
    stat, p_value = shapiro(diff_df[column])
    normality_results[column] = p_value

# Perform Appropriate Tests and Calculate Effect Sizes
results = {}
for column in diff_df.columns:
    if normality_results[column] < 0.05:
        # Non-normal distribution, use Wilcoxon Signed-Rank Test
        stat, p_value = wilcoxon(diff_df[column])
        # Calculate Rank-Biserial Correlation
        rbc = (diff_df[column] > 0).sum() - (diff_df[column] < 0).sum()
        rbc /= len(diff_df[column])
        results[column] = {'Test': 'Wilcoxon', 'p-value': p_value, 'Effect Size': rbc}
    else:
        # Normal distribution, use Paired t-test
        stat, p_value = ttest_rel(after_data[column], before_data[column])
        # Calculate Cohen's d
        cohen_d = (diff_df[column].mean()) / diff_df[column].std(ddof=1)
        results[column] = {'Test': 'Paired t-test', 'p-value': p_value, 'Effect Size': cohen_d}

# Display Results
summary_table = pd.DataFrame(results).T
print("Summary Table of Paired Comparisons:")
print(summary_table)

# Visualization
plt.figure(figsize=(12, 8))

for idx, column in enumerate(differences.keys(), 1):
    plt.subplot(2, 3, idx)
    plt.boxplot([before_data[column], after_data[column]], labels=['Before', 'After'])
    plt.title(f'{column} Before and After Surgery')
    plt.ylabel(column)

plt.tight_layout()
plt.show()

# Overall Summary in Plain Language
print("\nOverall Summary in Plain Language:")
print("Significant Improvements:\nAfter bypass surgery, patients experienced major improvements:")
print("Weight and BMI: Reduced dramatically.")
print("Migraine Disability (MIDAS): Lower scores mean less disability.")
print("Migraine Frequency and Severity: Both decreased significantly.")
print("Quality of Life (MSQ): Improved, as indicated by lower scores (which, in our study, mean less negative impact).")

print("\nLarge Effects:\nThe effect sizes (which measure how big the change is) are very high.")
for key in results:
    print(f"{key}: Effect Size = {results[key]['Effect Size']:.2f}")

print("\nWhat It Means:\nThe analysis shows that bypass surgery has a strong impact on reducing the negative effects of migraines, from physical measurements (like weight) to migraine-related scores. Even though our statistical tests confirm that these improvements are significant, the large effect sizes tell us that these improvements are substantial and meaningful.")

import pandas as pd
import matplotlib.pyplot as plt

# Load the datasets
before_data = pd.read_csv('Before_Data.csv')
after_data = pd.read_csv('After_Data.csv')

# Patient Pipeline Plot for MIDAS and MSQ
fig, axs = plt.subplots(1, 2, figsize=(16, 8), sharey=True)

# MIDAS Pipeline
for i in range(len(before_data)):
    axs[0].plot(['Before Surgery', 'After Surgery'],
                [before_data['MIDAS'].iloc[i], after_data['MIDAS'].iloc[i]],
                marker='o', linestyle='-', color='skyblue')
axs[0].set_title('Patient Pipeline for MIDAS Scores')
axs[0].set_ylabel('MIDAS Score')
axs[0].grid(True, linestyle='--', alpha=0.6)

# MSQ Pipeline
for i in range(len(before_data)):
    axs[1].plot(['Before Surgery', 'After Surgery'],
                [before_data['MSQ'].iloc[i], after_data['MSQ'].iloc[i]],
                marker='o', linestyle='-', color='lightcoral')
axs[1].set_title('Patient Pipeline for MSQ Scores')
axs[1].set_ylabel('MSQ Score')
axs[1].grid(True, linestyle='--', alpha=0.6)

plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Load the datasets
before_data = pd.read_csv('Before_Data.csv')
after_data = pd.read_csv('After_Data.csv')

# Patient Pipeline Plot for MIDAS and MSQ
fig, axs = plt.subplots(1, 2, figsize=(16, 8), sharey=True)

# MIDAS Pipeline
for i in range(len(before_data)):
    axs[0].plot(['Before Surgery', 'After Surgery'],
                [before_data['MIDAS'].iloc[i], after_data['MIDAS'].iloc[i]],
                marker='o', linestyle='-', color='skyblue', alpha=0.7)
axs[0].set_title('Patient Pipeline for MIDAS Scores')
axs[0].set_ylabel('MIDAS Score')
axs[0].grid(True, linestyle='--', alpha=0.6)

# MSQ Pipeline with adjusted scaling for clarity
for i in range(len(before_data)):
    axs[1].plot(['Before Surgery', 'After Surgery'],
                [before_data['MSQ'].iloc[i], after_data['MSQ'].iloc[i]],
                marker='o', linestyle='-', color='lightcoral', alpha=0.7)
axs[1].set_title('Patient Pipeline for MSQ Scores')
axs[1].set_ylabel('MSQ Score')
axs[1].set_ylim(0, max(before_data['MSQ'].max(), after_data['MSQ'].max()) + 10)
axs[1].grid(True, linestyle='--', alpha=0.6)

plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Load the datasets
before_data = pd.read_csv('Before_Data.csv')
after_data = pd.read_csv('After_Data.csv')

# Patient Pipeline Plot for MIDAS and MSQ
fig, axs = plt.subplots(1, 2, figsize=(16, 8), sharey=False)

# MIDAS Pipeline (Keep original scaling)
for i in range(len(before_data)):
    axs[0].plot(['Before Surgery', 'After Surgery'],
                [before_data['MIDAS'].iloc[i], after_data['MIDAS'].iloc[i]],
                marker='o', linestyle='-', color='skyblue', alpha=0.7)
axs[0].set_title('Patient Pipeline for MIDAS Scores')
axs[0].set_ylabel('MIDAS Score')
axs[0].grid(True, linestyle='--', alpha=0.6)

# MSQ Pipeline (Adjusted scaling for clarity)
for i in range(len(before_data)):
    axs[1].plot(['Before Surgery', 'After Surgery'],
                [before_data['MSQ'].iloc[i], after_data['MSQ'].iloc[i]],
                marker='o', linestyle='-', color='lightcoral', alpha=0.7)
axs[1].set_title('Patient Pipeline for MSQ Scores')
axs[1].set_ylabel('MSQ Score')
axs[1].set_ylim(before_data['MSQ'].min() - 5, after_data['MSQ'].max() + 5)
axs[1].grid(True, linestyle='--', alpha=0.6)

plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Load the datasets
before_data = pd.read_csv('Before_Data.csv')
after_data = pd.read_csv('After_Data.csv')

# Calculate range to adjust scaling dynamically
midas_range = before_data['MIDAS'].max() - before_data['MIDAS'].min()
msq_range = before_data['MSQ'].max() - before_data['MSQ'].min()

# Determine appropriate y-limits with more compact scaling
midas_ylim = (before_data['MIDAS'].min() - 0.05 * midas_range, after_data['MIDAS'].max() + 0.05 * midas_range)
msq_ylim = (before_data['MSQ'].min() - 0.1 * msq_range, after_data['MSQ'].max() + 0.1 * msq_range)

# Plotting the patient pipeline for MIDAS and MSQ
fig, axs = plt.subplots(1, 2, figsize=(14, 7))

# MIDAS Pipeline with compact scaling
for i in range(len(before_data)):
    axs[0].plot(['Before Surgery', 'After Surgery'],
                [before_data['MIDAS'].iloc[i], after_data['MIDAS'].iloc[i]],
                marker='o', linestyle='-', color='skyblue', alpha=0.6)
axs[0].set_title('Patient Pipeline for MIDAS Scores')
axs[0].set_ylabel('MIDAS Score')
axs[0].set_ylim(midas_ylim)
axs[0].grid(True, linestyle='--', alpha=0.6)

# MSQ Pipeline with compact scaling
for i in range(len(before_data)):
    axs[1].plot(['Before Surgery', 'After Surgery'],
                [before_data['MSQ'].iloc[i], after_data['MSQ'].iloc[i]],
                marker='o', linestyle='-', color='lightcoral', alpha=0.6)
axs[1].set_title('Patient Pipeline for MSQ Scores')
axs[1].set_ylabel('MSQ Score')
axs[1].set_ylim(msq_ylim)
axs[1].grid(True, linestyle='--', alpha=0.6)

plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Load the datasets
before_data = pd.read_csv('Before_Data.csv')
after_data = pd.read_csv('After_Data.csv')

# Calculate range to adjust scaling dynamically
midas_range = before_data['MIDAS'].max() - before_data['MIDAS'].min()
msq_range = before_data['MSQ'].max() - before_data['MSQ'].min()

# Determine appropriate y-limits with zoomed-out scaling
midas_ylim = (before_data['MIDAS'].min() - 0.2 * midas_range, after_data['MIDAS'].max() + 0.2 * midas_range)
msq_ylim = (before_data['MSQ'].min() - 0.3 * msq_range, after_data['MSQ'].max() + 0.3 * msq_range)

# Plotting the patient pipeline for MIDAS and MSQ
fig, axs = plt.subplots(1, 2, figsize=(18, 8))

# MIDAS Pipeline with zoomed-out scaling
for i in range(len(before_data)):
    axs[0].plot(['Before Surgery', 'After Surgery'],
                [before_data['MIDAS'].iloc[i], after_data['MIDAS'].iloc[i]],
                marker='o', linestyle='-', color='skyblue', alpha=0.6)
axs[0].set_title('Patient Pipeline for MIDAS Scores')
axs[0].set_ylabel('MIDAS Score')
axs[0].set_ylim(midas_ylim)
axs[0].grid(True, linestyle='--', alpha=0.6)

# MSQ Pipeline with zoomed-out scaling
for i in range(len(before_data)):
    axs[1].plot(['Before Surgery', 'After Surgery'],
                [before_data['MSQ'].iloc[i], after_data['MSQ'].iloc[i]],
                marker='o', linestyle='-', color='lightcoral', alpha=0.6)
axs[1].set_title('Patient Pipeline for MSQ Scores')
axs[1].set_ylabel('MSQ Score')
axs[1].set_ylim(msq_ylim)
axs[1].grid(True, linestyle='--', alpha=0.6)

plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Load the datasets
before_data = pd.read_csv('Before_Data.csv')
after_data = pd.read_csv('After_Data.csv')

# Calculate range to adjust scaling dynamically
midas_range = before_data['MIDAS'].max() - before_data['MIDAS'].min()
msq_range = before_data['MSQ'].max() - before_data['MSQ'].min()

# Determine appropriate y-limits with further zoomed-out scaling
midas_ylim = (before_data['MIDAS'].min() - 0.4 * midas_range, after_data['MIDAS'].max() + 0.4 * midas_range)
msq_ylim = (before_data['MSQ'].min() - 0.5 * msq_range, after_data['MSQ'].max() + 0.5 * msq_range)

# Plotting the patient pipeline for MIDAS and MSQ
fig, axs = plt.subplots(1, 2, figsize=(20, 10))

# MIDAS Pipeline with more zoomed-out scaling
for i in range(len(before_data)):
    axs[0].plot(['Before Surgery', 'After Surgery'],
                [before_data['MIDAS'].iloc[i], after_data['MIDAS'].iloc[i]],
                marker='o', linestyle='-', color='skyblue', alpha=0.6)
axs[0].set_title('Patient Pipeline for MIDAS Scores')
axs[0].set_ylabel('MIDAS Score')
axs[0].set_ylim(midas_ylim)
axs[0].grid(True, linestyle='--', alpha=0.6)

# MSQ Pipeline with more zoomed-out scaling
for i in range(len(before_data)):
    axs[1].plot(['Before Surgery', 'After Surgery'],
                [before_data['MSQ'].iloc[i], after_data['MSQ'].iloc[i]],
                marker='o', linestyle='-', color='lightcoral', alpha=0.6)
axs[1].set_title('Patient Pipeline for MSQ Scores')
axs[1].set_ylabel('MSQ Score')
axs[1].set_ylim(msq_ylim)
axs[1].grid(True, linestyle='--', alpha=0.6)

plt.tight_layout()
plt.show()

import pandas as pd
from scipy.stats import wilcoxon, ttest_rel, shapiro
import numpy as np
import matplotlib.pyplot as plt

# Load the datasets
before_data = pd.read_csv('Before_Data.csv')
after_data = pd.read_csv('After_Data.csv')

# Calculate Paired Differences
differences = {
    'Weight': after_data['Weight'] - before_data['Weight'],
    'BMI': after_data['BMI'] - before_data['BMI'],
    'Severity': after_data['Severity'] - before_data['Severity'],
    'Frequency': after_data['Frequency'] - before_data['Frequency'],
    'MIDAS': after_data['MIDAS'] - before_data['MIDAS'],
    'MSQ': after_data['MSQ'] - before_data['MSQ']
}

diff_df = pd.DataFrame(differences)

# Test for Normality using Shapiro-Wilk Test
normality_results = {}
for column in diff_df.columns:
    stat, p_value = shapiro(diff_df[column])
    normality_results[column] = p_value

# Perform Appropriate Tests and Calculate Effect Sizes
results = {}
for column in diff_df.columns:
    if normality_results[column] < 0.05:
        # Non-normal distribution, use Wilcoxon Signed-Rank Test
        stat, p_value = wilcoxon(diff_df[column])
        # Calculate Rank-Biserial Correlation
        rbc = (diff_df[column] > 0).sum() - (diff_df[column] < 0).sum()
        rbc /= len(diff_df[column])
        results[column] = {'Test': 'Wilcoxon', 'p-value': p_value, 'Effect Size': round(rbc, 2)}
    else:
        # Normal distribution, use Paired t-test
        stat, p_value = ttest_rel(after_data[column], before_data[column])
        # Calculate Cohen's d
        cohen_d = (diff_df[column].mean()) / diff_df[column].std(ddof=1)
        results[column] = {'Test': 'Paired t-test', 'p-value': p_value, 'Effect Size': round(cohen_d, 2)}

# Display Results
summary_table = pd.DataFrame(results).T
print("Summary Table of Paired Comparisons:")
print(summary_table)

# Interpretation in Plain Language
print("\nOverall Summary in Plain Language:")
print("Significant Improvements:\nAfter bypass surgery, patients experienced major improvements:")
print("Weight and BMI: Reduced dramatically.")
print("Migraine Disability (MIDAS): Lower scores mean less disability.")
print("Migraine Frequency and Severity: Both decreased significantly.")
print("Quality of Life (MSQ): Improved, as indicated by lower scores (which, in our study, mean less negative impact).")

print("\nLarge Effects:\nThe effect sizes (which measure how big the change is) are very high.")
for key in results:
    print(f"{key}: Effect Size = {results[key]['Effect Size']}")

print("\nWhat It Means:\nThe analysis shows that bypass surgery has a strong impact on reducing the negative effects of migraines, from physical measurements (like weight) to migraine-related scores. Even though our statistical tests confirm that these improvements are significant, the large effect sizes tell us that these improvements are substantial and meaningful.")

# Visualization
plt.figure(figsize=(12, 8))

for idx, column in enumerate(differences.keys(), 1):
    plt.subplot(2, 3, idx)
    plt.boxplot([before_data[column], after_data[column]], tick_labels=['Before', 'After'])
    plt.title(f'{column} Before and After Surgery')
    plt.ylabel(column)

plt.tight_layout()
plt.show()

import pandas as pd
from scipy.stats import wilcoxon, ttest_rel, shapiro
import numpy as np

# Load the datasets
before_data = pd.read_csv('Before_Data.csv')
after_data = pd.read_csv('After_Data.csv')

# List of metrics to analyze
metrics = ['Weight', 'BMI', 'Severity', 'Frequency', 'MIDAS', 'MSQ']

# Calculate Paired Differences
differences = {metric: after_data[metric] - before_data[metric] for metric in metrics}
diff_df = pd.DataFrame(differences)

# Initialize result storage
normality_results = {}
statistical_tests = {}
effect_sizes = {}

# Analysis loop for each metric
for metric in metrics:
    # Shapiro-Wilk Test for normality
    stat, p_norm = shapiro(diff_df[metric])
    normality_results[metric] = p_norm

    if p_norm < 0.05:
        # Non-normal distribution: Wilcoxon Signed-Rank Test
        stat, p_value = wilcoxon(diff_df[metric])
        # Rank-Biserial Correlation for effect size
        rbc = (diff_df[metric] > 0).sum() - (diff_df[metric] < 0).sum()
        rbc /= len(diff_df[metric])
        statistical_tests[metric] = 'Wilcoxon Signed-Rank Test'
        effect_sizes[metric] = round(rbc, 2)
    else:
        # Normal distribution: Paired t-test
        stat, p_value = ttest_rel(after_data[metric], before_data[metric])
        # Cohen's d for effect size
        cohen_d = diff_df[metric].mean() / diff_df[metric].std(ddof=1)
        statistical_tests[metric] = 'Paired t-test'
        effect_sizes[metric] = round(cohen_d, 2)

    # Store p-value
    statistical_tests[metric] += f' (p-value: {p_value:.4f})'

# Create Summary Table
summary_table = pd.DataFrame({
    'Test': [statistical_tests[metric] for metric in metrics],
    'Normality p-value': [round(normality_results[metric], 4) for metric in metrics],
    'Effect Size': [effect_sizes[metric] for metric in metrics]
}, index=metrics)

# Display Summary Table
print("Summary Table of Paired Comparisons:")
print(summary_table)

# Overall Summary in Plain Language
print("\nOverall Summary in Plain Language:")
print("Significant Improvements:\nAfter bypass surgery, patients experienced major improvements:")
print("Weight and BMI: Reduced dramatically.")
print("Migraine Disability (MIDAS): Lower scores mean less disability.")
print("Migraine Frequency and Severity: Both decreased significantly.")
print("Quality of Life (MSQ): Improved, as indicated by lower scores (which, in our study, mean less negative impact).")

print("\nLarge Effects:\nThe effect sizes (which measure how big the change is) are very high.")
for metric in metrics:
    print(f"{metric}: Effect Size = {effect_sizes[metric]}")

print("\nWhat It Means:\nThe analysis shows that bypass surgery has a strong impact on reducing the negative effects of migraines, from physical measurements (like weight) to migraine-related scores. Even though our statistical tests confirm that these improvements are significant, the large effect sizes tell us that these improvements are substantial and meaningful.")

import pandas as pd
import numpy as np
from scipy.stats import wilcoxon, ttest_rel, shapiro

# Load the datasets
before_data = pd.read_csv('Before_Data.csv')
after_data = pd.read_csv('After_Data.csv')

# List of metrics to analyze
metrics = ['Weight', 'BMI', 'Severity', 'Frequency', 'MIDAS', 'MSQ']

# Calculate Paired Differences
differences = {metric: after_data[metric] - before_data[metric] for metric in metrics}
diff_df = pd.DataFrame(differences)

# Initialize result storage
normality_results = {}
statistical_tests = {}
effect_sizes = {}
mean_std_results = {}

# Analysis loop for each metric
for metric in metrics:
    # Calculate Mean ± SD for Before and After
    before_mean = before_data[metric].mean()
    before_std = before_data[metric].std()
    after_mean = after_data[metric].mean()
    after_std = after_data[metric].std()

    mean_std_results[metric] = {
        'Before Surgery': f"{before_mean:.1f} ± {before_std:.1f}",
        'After Surgery': f"{after_mean:.1f} ± {after_std:.1f}"
    }

    # Shapiro-Wilk Test for normality
    stat, p_norm = shapiro(diff_df[metric])
    normality_results[metric] = p_norm

    if p_norm < 0.05:
        # Non-normal distribution: Wilcoxon Signed-Rank Test
        stat, p_value = wilcoxon(diff_df[metric])
        # Rank-Biserial Correlation for effect size
        rbc = (diff_df[metric] > 0).sum() - (diff_df[metric] < 0).sum()
        rbc /= len(diff_df[metric])
        statistical_tests[metric] = 'Wilcoxon Signed-Rank Test'
        effect_sizes[metric] = round(rbc, 2)
    else:
        # Normal distribution: Paired t-test
        stat, p_value = ttest_rel(after_data[metric], before_data[metric])
        # Cohen's d for effect size
        cohen_d = diff_df[metric].mean() / diff_df[metric].std(ddof=1)
        statistical_tests[metric] = 'Paired t-test'
        effect_sizes[metric] = round(cohen_d, 2)

    # Store p-value
    statistical_tests[metric] += f' (p-value: {p_value:.4f})'

# Create Summary Table
summary_table = pd.DataFrame({
    'Test': [statistical_tests[metric] for metric in metrics],
    'Normality p-value': [round(normality_results[metric], 4) for metric in metrics],
    'Effect Size': [effect_sizes[metric] for metric in metrics],
    'Before Surgery (Mean ± SD)': [mean_std_results[metric]['Before Surgery'] for metric in metrics],
    'After Surgery (Mean ± SD)': [mean_std_results[metric]['After Surgery'] for metric in metrics]
}, index=metrics)

# Display Summary Table
print("Summary Table of Paired Comparisons:")
print(summary_table)

# Overall Summary in Plain Language
print("\nOverall Summary in Plain Language:")
print("Significant Improvements:\nAfter bypass surgery, patients experienced major improvements:")
print("Weight and BMI: Reduced dramatically.")
print("Migraine Disability (MIDAS): Lower scores mean less disability.")
print("Migraine Frequency and Severity: Both decreased significantly.")
print("Quality of Life (MSQ): Improved, as indicated by lower scores (which, in our study, mean less negative impact).")

print("\nLarge Effects:\nThe effect sizes (which measure how big the change is) are very high.")
for metric in metrics:
    print(f"{metric}: Effect Size = {effect_sizes[metric]}")

print("\nWhat It Means:\nThe analysis shows that bypass surgery has a strong impact on reducing the negative effects of migraines, from physical measurements (like weight) to migraine-related scores. Even though our statistical tests confirm that these improvements are significant, the large effect sizes tell us that these improvements are substantial and meaningful.")

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Load the datasets
before_data = pd.read_csv('Before_Data.csv')
after_data = pd.read_csv('After_Data.csv')

# List of metrics to visualize
metrics = ['Weight', 'BMI', 'Severity', 'Frequency', 'MIDAS', 'MSQ']

# Set up visualization style
sns.set(style="whitegrid")

# 1. Boxplots for Before and After Comparisons
plt.figure(figsize=(18, 12))

for idx, metric in enumerate(metrics, 1):
    plt.subplot(2, 3, idx)
    sns.boxplot(data=[before_data[metric], after_data[metric]], palette="Set2")
    plt.xticks([0, 1], ['Before Surgery', 'After Surgery'])
    plt.title(f'{metric} Before and After Surgery')
    plt.ylabel(metric)

plt.tight_layout()
plt.show()

# 2. Line Plot for Individual Patient Pipelines
fig, axs = plt.subplots(2, 3, figsize=(20, 12))
axs = axs.flatten()

for idx, metric in enumerate(metrics):
    for i in range(len(before_data)):
        axs[idx].plot(['Before Surgery', 'After Surgery'],
                      [before_data[metric].iloc[i], after_data[metric].iloc[i]],
                      marker='o', linestyle='-', alpha=0.6)
    axs[idx].set_title(f'Patient Pipeline for {metric}')
    axs[idx].set_ylabel(metric)
    axs[idx].grid(True, linestyle='--', alpha=0.6)

plt.tight_layout()
plt.show()

# 3. Bar Plot of Mean ± SD for Each Metric
mean_std_before = before_data[metrics].mean()
std_before = before_data[metrics].std()
mean_std_after = after_data[metrics].mean()
std_after = after_data[metrics].std()

x = range(len(metrics))

plt.figure(figsize=(14, 8))

plt.bar(x, mean_std_before, yerr=std_before, alpha=0.6, label='Before Surgery', capsize=5)
plt.bar(x, mean_std_after, yerr=std_after, alpha=0.6, label='After Surgery', capsize=5)

plt.xticks(x, metrics)
plt.ylabel('Mean ± SD')
plt.title('Comparison of Metrics Before and After Surgery')
plt.legend()
plt.grid(axis='y', linestyle='--', alpha=0.7)

plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Load the datasets
before_data = pd.read_csv('Before_Data.csv')
after_data = pd.read_csv('After_Data.csv')

# List of metrics to visualize
metrics = ['Weight', 'BMI', 'Severity', 'Frequency', 'MIDAS', 'MSQ']

# Set up visualization style
sns.set(style="whitegrid")

# 1. Boxplots for Before and After Comparisons
plt.figure(figsize=(18, 12))

for idx, metric in enumerate(metrics, 1):
    plt.subplot(2, 3, idx)
    sns.boxplot(data=[before_data[metric], after_data[metric]], palette="Set2")
    plt.xticks([0, 1], ['Before Surgery', 'After Surgery'])
    plt.title(f'{metric} Before and After Surgery')
    plt.ylabel(metric)

plt.tight_layout()
plt.show()

# 2. Line Plot for Individual Patient Pipelines
fig, axs = plt.subplots(2, 3, figsize=(20, 12))
axs = axs.flatten()

for idx, metric in enumerate(metrics):
    for i in range(len(before_data)):
        axs[idx].plot(['Before Surgery', 'After Surgery'],
                      [before_data[metric].iloc[i], after_data[metric].iloc[i]],
                      marker='o', linestyle='-', alpha=0.6)
    axs[idx].set_title(f'Patient Pipeline for {metric}')
    axs[idx].set_ylabel(metric)
    axs[idx].grid(True, linestyle='--', alpha=0.6)

plt.tight_layout()
plt.show()

# 3. Bar Plot of Mean ± SD for Each Metric
mean_std_before = before_data[metrics].mean()
std_before = before_data[metrics].std()
mean_std_after = after_data[metrics].mean()
std_after = after_data[metrics].std()

x = range(len(metrics))

plt.figure(figsize=(14, 8))

plt.bar(x, mean_std_before, yerr=std_before, alpha=0.6, label='Before Surgery', capsize=5)
plt.bar(x, mean_std_after, yerr=std_after, alpha=0.6, label='After Surgery', capsize=5)

plt.xticks(x, metrics)
plt.ylabel('Mean ± SD')
plt.title('Comparison of Metrics Before and After Surgery')
plt.legend()
plt.grid(axis='y', linestyle='--', alpha=0.7)

plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Load the datasets
before_data = pd.read_csv('Before_Data.csv')
after_data = pd.read_csv('After_Data.csv')

# Set up visualization style
sns.set(style="whitegrid")

# Metrics to visualize
metrics = ['MIDAS', 'MSQ']

# 1. Line Plot for Individual Patient Pipelines (MIDAS and MSQ)
fig, axs = plt.subplots(1, 2, figsize=(16, 8))

for idx, metric in enumerate(metrics):
    for i in range(len(before_data)):
        axs[idx].plot(['Before Surgery', 'After Surgery'],
                      [before_data[metric].iloc[i], after_data[metric].iloc[i]],
                      marker='o', linestyle='-', alpha=0.6)
    axs[idx].set_title(f'Patient Pipeline for {metric}')
    axs[idx].set_ylabel(metric)
    axs[idx].grid(True, linestyle='--', alpha=0.6)

plt.tight_layout()
plt.show()

# 2. Boxplots Comparing MIDAS and MSQ Before and After
plt.figure(figsize=(12, 6))

for idx, metric in enumerate(metrics, 1):
    plt.subplot(1, 2, idx)
    sns.boxplot(data=[before_data[metric], after_data[metric]], palette="Set2")
    plt.xticks([0, 1], ['Before Surgery', 'After Surgery'])
    plt.title(f'{metric} Before and After Surgery')
    plt.ylabel(metric)

plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Load the datasets
before_data = pd.read_csv('Before_Data.csv')
after_data = pd.read_csv('After_Data.csv')

# Set up visualization style
sns.set(style="whitegrid")

# Metrics to visualize
metrics = ['MIDAS', 'MSQ']

# 1. Line Plot for Individual Patient Pipelines (MIDAS and MSQ)
fig, axs = plt.subplots(1, 2, figsize=(16, 8))

for idx, metric in enumerate(metrics):
    for i in range(len(before_data)):
        axs[idx].plot(['Before Surgery', 'After Surgery'],
                      [before_data[metric].iloc[i], after_data[metric].iloc[i]],
                      marker='o', linestyle='-', alpha=0.6)
    axs[idx].set_title(f'Patient Pipeline for {metric}')
    axs[idx].set_ylabel(metric)
    axs[idx].set_ylim(min(before_data[metric].min(), after_data[metric].min()) - 10,
                      max(before_data[metric].max(), after_data[metric].max()) + 10)
    axs[idx].grid(True, linestyle='--', alpha=0.6)

plt.tight_layout()
plt.show()

# 2. Boxplots Comparing MIDAS and MSQ Before and After with Rescaling
plt.figure(figsize=(12, 6))

for idx, metric in enumerate(metrics, 1):
    plt.subplot(1, 2, idx)
    sns.boxplot(data=[before_data[metric], after_data[metric]], palette="Set2")
    plt.xticks([0, 1], ['Before Surgery', 'After Surgery'])
    plt.title(f'{metric} Before and After Surgery')
    plt.ylabel(metric)
    plt.ylim(min(before_data[metric].min(), after_data[metric].min()) - 10,
             max(before_data[metric].max(), after_data[metric].max()) + 10)

plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Load the datasets
before_data = pd.read_csv('Before_Data.csv')
after_data = pd.read_csv('After_Data.csv')

# Set up visualization style
sns.set(style="whitegrid")

# Metrics to visualize
metrics = ['MIDAS', 'MSQ']

# 1. Line Plot for Individual Patient Pipelines (MIDAS and MSQ)
fig, axs = plt.subplots(1, 2, figsize=(16, 8))

for idx, metric in enumerate(metrics):
    for i in range(len(before_data)):
        axs[idx].plot(['Before Surgery', 'After Surgery'],
                      [before_data[metric].iloc[i], after_data[metric].iloc[i]],
                      marker='o', linestyle='-', alpha=0.6)
    axs[idx].set_title(f'Patient Pipeline for {metric}')
    axs[idx].set_ylabel(metric)
    # Adjust scaling with dynamic padding
    min_val = min(before_data[metric].min(), after_data[metric].min()) * 0.9
    max_val = max(before_data[metric].max(), after_data[metric].max()) * 1.1
    axs[idx].set_ylim(min_val, max_val)
    axs[idx].grid(True, linestyle='--', alpha=0.6)

plt.tight_layout()
plt.show()

# 2. Boxplots Comparing MIDAS and MSQ Before and After with Dynamic Rescaling
plt.figure(figsize=(12, 6))

for idx, metric in enumerate(metrics, 1):
    plt.subplot(1, 2, idx)
    sns.boxplot(data=[before_data[metric], after_data[metric]], palette="Set2")
    plt.xticks([0, 1], ['Before Surgery', 'After Surgery'])
    plt.title(f'{metric} Before and After Surgery')
    plt.ylabel(metric)
    # Dynamically adjust y-limits for clean visualization
    min_val = min(before_data[metric].min(), after_data[metric].min()) * 0.9
    max_val = max(before_data[metric].max(), after_data[metric].max()) * 1.1
    plt.ylim(min_val, max_val)

plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Load the datasets
before_data = pd.read_csv('Before_Data.csv')
after_data = pd.read_csv('After_Data.csv')

# Set up visualization style
sns.set(style="whitegrid")

# Metrics to visualize
metrics = ['MIDAS', 'MSQ']

# 1. Line Plot for Individual Patient Pipelines (MIDAS and MSQ)
fig, axs = plt.subplots(1, 2, figsize=(16, 8))

for idx, metric in enumerate(metrics):
    for i in range(len(before_data)):
        axs[idx].plot(['Before Surgery', 'After Surgery'],
                      [before_data[metric].iloc[i], after_data[metric].iloc[i]],
                      marker='o', linestyle='-', alpha=0.6)
    axs[idx].set_title(f'Patient Pipeline for {metric}')
    axs[idx].set_ylabel(metric)
    # Adjust scaling with dynamic padding
    min_val = min(before_data[metric].min(), after_data[metric].min()) * 0.9
    max_val = max(before_data[metric].max(), after_data[metric].max()) * 1.1
    axs[idx].set_ylim(min_val, max_val)
    axs[idx].grid(True, linestyle='--', alpha=0.6)

plt.tight_layout()
plt.show()

# 2. Boxplots Comparing MIDAS and MSQ Before and After with Dynamic Rescaling
plt.figure(figsize=(12, 6))

for idx, metric in enumerate(metrics, 1):
    plt.subplot(1, 2, idx)
    sns.boxplot(data=[before_data[metric], after_data[metric]], palette="Set2")
    plt.xticks([0, 1], ['Before Surgery', 'After Surgery'])
    plt.title(f'{metric} Before and After Surgery')
    plt.ylabel(metric)
    # Dynamically adjust y-limits for clean visualization
    min_val = min(before_data[metric].min(), after_data[metric].min()) * 0.9
    max_val = max(before_data[metric].max(), after_data[metric].max()) * 1.1
    plt.ylim(min_val, max_val)

plt.tight_layout()
plt.show()

import pandas as pd
from scipy.stats import pearsonr, spearmanr, shapiro
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seaborn as sns

# Load the datasets
before_data = pd.read_csv('Before_Data.csv')
after_data = pd.read_csv('After_Data.csv')

# Calculate changes for correlation analysis
changes = pd.DataFrame()
changes['Weight_Loss'] = before_data['Weight'] - after_data['Weight']
changes['BMI_Change'] = before_data['BMI'] - after_data['BMI']
changes['Migraine_Frequency_Change'] = before_data['Frequency'] - after_data['Frequency']
changes['Migraine_Severity_Change'] = before_data['Severity'] - after_data['Severity']
changes['MSQ_Improvement'] = before_data['MSQ'] - after_data['MSQ']

# 1. Correlation Analysis
correlation_results = {}

# Check normality to decide Pearson or Spearman
for col1, col2 in [('Weight_Loss', 'Migraine_Frequency_Change'),
                   ('Weight_Loss', 'Migraine_Severity_Change'),
                   ('BMI_Change', 'MSQ_Improvement')]:
    # Normality tests
    stat1, p_norm1 = shapiro(changes[col1])
    stat2, p_norm2 = shapiro(changes[col2])

    if p_norm1 > 0.05 and p_norm2 > 0.05:
        # Both normal: Pearson
        corr, p_value = pearsonr(changes[col1], changes[col2])
        correlation_type = 'Pearson'
    else:
        # Non-normal: Spearman
        corr, p_value = spearmanr(changes[col1], changes[col2])
        correlation_type = 'Spearman'

    correlation_results[f'{col1} vs {col2}'] = {
        'Correlation Type': correlation_type,
        'Correlation Coefficient': round(corr, 3),
        'p-value': round(p_value, 4)
    }

# Display Correlation Results
print("Correlation Analysis Results:")
for key, value in correlation_results.items():
    print(f"{key}: {value['Correlation Type']} Correlation = {value['Correlation Coefficient']} (p-value = {value['p-value']})")

# 2. Regression Analysis
# Linear regression: Does BMI change predict MSQ improvement?
X = changes['BMI_Change']
Y = changes['MSQ_Improvement']
X = sm.add_constant(X)  # Adds a constant term to the predictor

model = sm.OLS(Y, X).fit()
print("\nLinear Regression Results (BMI Change predicting MSQ Improvement):")
print(model.summary())

# 3. Visualization of Correlation and Regression
sns.set(style="whitegrid")

# Correlation Plots
plt.figure(figsize=(12, 4))

plt.subplot(1, 2, 1)
sns.scatterplot(x='Weight_Loss', y='Migraine_Frequency_Change', data=changes)
plt.title('Weight Loss vs Migraine Frequency Reduction')
plt.xlabel('Weight Loss (kg)')
plt.ylabel('Migraine Frequency Reduction')

plt.subplot(1, 2, 2)
sns.scatterplot(x='BMI_Change', y='MSQ_Improvement', data=changes)
plt.title('BMI Change vs MSQ Improvement')
plt.xlabel('BMI Change')
plt.ylabel('MSQ Improvement')

plt.tight_layout()
plt.show()

# Regression Plot
plt.figure(figsize=(8, 6))
sns.regplot(x='BMI_Change', y='MSQ_Improvement', data=changes, ci=None, line_kws={"color":"red"})
plt.title('Regression: BMI Change Predicting MSQ Improvement')
plt.xlabel('BMI Change')
plt.ylabel('MSQ Improvement')
plt.grid(True, linestyle='--', alpha=0.7)
plt.show()

import pandas as pd
from scipy.stats import pearsonr, spearmanr, shapiro
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seaborn as sns

# Load the datasets
before_data = pd.read_csv('Before_Data.csv')
after_data = pd.read_csv('After_Data.csv')

# Calculate changes for correlation analysis
changes = pd.DataFrame()
changes['Weight_Loss'] = before_data['Weight'] - after_data['Weight']
changes['BMI_Change'] = before_data['BMI'] - after_data['BMI']
changes['Migraine_Frequency_Change'] = before_data['Frequency'] - after_data['Frequency']
changes['Migraine_Severity_Change'] = before_data['Severity'] - after_data['Severity']
changes['MSQ_Improvement'] = before_data['MSQ'] - after_data['MSQ']

# 1. Correlation Analysis
correlation_results = {}

# Check normality to decide Pearson or Spearman
for col1, col2 in [('Weight_Loss', 'Migraine_Frequency_Change'),
                   ('Weight_Loss', 'Migraine_Severity_Change'),
                   ('BMI_Change', 'MSQ_Improvement')]:
    # Normality tests
    stat1, p_norm1 = shapiro(changes[col1])
    stat2, p_norm2 = shapiro(changes[col2])

    if p_norm1 > 0.05 and p_norm2 > 0.05:
        # Both normal: Pearson
        corr, p_value = pearsonr(changes[col1], changes[col2])
        correlation_type = 'Pearson'
    else:
        # Non-normal: Spearman
        corr, p_value = spearmanr(changes[col1], changes[col2])
        correlation_type = 'Spearman'

    correlation_results[f'{col1} vs {col2}'] = {
        'Correlation Type': correlation_type,
        'Correlation Coefficient': round(corr, 3),
        'p-value': round(p_value, 4)
    }

# Display Correlation Results
print("Correlation Analysis Results:")
for key, value in correlation_results.items():
    print(f"{key}: {value['Correlation Type']} Correlation = {value['Correlation Coefficient']} (p-value = {value['p-value']})")

# 2. Regression Analysis
# Linear regression: Does BMI change predict MSQ improvement?
X = changes['BMI_Change']
Y = changes['MSQ_Improvement']
X = sm.add_constant(X)  # Adds a constant term to the predictor

model = sm.OLS(Y, X).fit()
print("\nLinear Regression Results (BMI Change predicting MSQ Improvement):")
print(model.summary())

# 3. Visualization of Correlation and Regression
sns.set(style="whitegrid")

# Correlation Plots
plt.figure(figsize=(12, 4))

plt.subplot(1, 2, 1)
sns.scatterplot(x='Weight_Loss', y='Migraine_Frequency_Change', data=changes)
plt.title('Weight Loss vs Migraine Frequency Reduction')
plt.xlabel('Weight Loss (kg)')
plt.ylabel('Migraine Frequency Reduction')

plt.subplot(1, 2, 2)
sns.scatterplot(x='BMI_Change', y='MSQ_Improvement', data=changes)
plt.title('BMI Change vs MSQ Improvement')
plt.xlabel('BMI Change')
plt.ylabel('MSQ Improvement')

plt.tight_layout()
plt.show()

# Regression Plot
plt.figure(figsize=(8, 6))
sns.regplot(x='BMI_Change', y='MSQ_Improvement', data=changes, ci=None, line_kws={"color":"red"})
plt.title('Regression: BMI Change Predicting MSQ Improvement')
plt.xlabel('BMI Change')
plt.ylabel('MSQ Improvement')
plt.grid(True, linestyle='--', alpha=0.7)
plt.show()

import pandas as pd
from scipy.stats import pearsonr, spearmanr, shapiro
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seaborn as sns

# Load the datasets
before_data = pd.read_csv('Before_Data.csv')
after_data = pd.read_csv('After_Data.csv')

# Calculate changes for correlation and regression analysis
changes = pd.DataFrame()
changes['Weight_Loss'] = before_data['Weight'] - after_data['Weight']
changes['BMI_Change'] = before_data['BMI'] - after_data['BMI']
changes['Migraine_Frequency_Change'] = before_data['Frequency'] - after_data['Frequency']
changes['Migraine_Severity_Change'] = before_data['Severity'] - after_data['Severity']
changes['MIDAS_Improvement'] = before_data['MIDAS'] - after_data['MIDAS']
changes['MSQ_Improvement'] = before_data['MSQ'] - after_data['MSQ']

# 1. Correlation Analysis
correlation_results = {}

# Check normality to decide Pearson or Spearman
correlation_pairs = [
    ('Weight_Loss', 'Migraine_Frequency_Change'),
    ('Weight_Loss', 'Migraine_Severity_Change'),
    ('BMI_Change', 'MSQ_Improvement'),
    ('Weight_Loss', 'MIDAS_Improvement'),
    ('BMI_Change', 'MIDAS_Improvement'),
    ('MIDAS_Improvement', 'MSQ_Improvement')
]

for col1, col2 in correlation_pairs:
    # Normality tests
    stat1, p_norm1 = shapiro(changes[col1])
    stat2, p_norm2 = shapiro(changes[col2])

    if p_norm1 > 0.05 and p_norm2 > 0.05:
        # Both normal: Pearson
        corr, p_value = pearsonr(changes[col1], changes[col2])
        correlation_type = 'Pearson'
    else:
        # Non-normal: Spearman
        corr, p_value = spearmanr(changes[col1], changes[col2])
        correlation_type = 'Spearman'

    correlation_results[f'{col1} vs {col2}'] = {
        'Correlation Type': correlation_type,
        'Correlation Coefficient': round(corr, 3),
        'p-value': round(p_value, 4)
    }

# Display Correlation Results
print("Correlation Analysis Results:")
for key, value in correlation_results.items():
    print(f"{key}: {value['Correlation Type']} Correlation = {value['Correlation Coefficient']} (p-value = {value['p-value']})")

# 2. Regression Analysis
# Multiple linear regression: Predicting MSQ Improvement using BMI Change, MIDAS Improvement, and Weight Loss
X = changes[['BMI_Change', 'MIDAS_Improvement', 'Weight_Loss']]
Y = changes['MSQ_Improvement']
X = sm.add_constant(X)  # Adds a constant term to the predictor

model = sm.OLS(Y, X).fit()
print("\nMultiple Linear Regression Results (Predicting MSQ Improvement):")
print(model.summary())

# 3. Visualization of Correlation and Regression
sns.set(style="whitegrid")

# Correlation Plots
plt.figure(figsize=(18, 6))

plt.subplot(1, 3, 1)
sns.scatterplot(x='Weight_Loss', y='Migraine_Frequency_Change', data=changes)
plt.title('Weight Loss vs Migraine Frequency Reduction')
plt.xlabel('Weight Loss (kg)')
plt.ylabel('Migraine Frequency Reduction')

plt.subplot(1, 3, 2)
sns.scatterplot(x='BMI_Change', y='MSQ_Improvement', data=changes)
plt.title('BMI Change vs MSQ Improvement')
plt.xlabel('BMI Change')
plt.ylabel('MSQ Improvement')

plt.subplot(1, 3, 3)
sns.scatterplot(x='MIDAS_Improvement', y='MSQ_Improvement', data=changes)
plt.title('MIDAS Improvement vs MSQ Improvement')
plt.xlabel('MIDAS Improvement')
plt.ylabel('MSQ Improvement')

plt.tight_layout()
plt.show()

# Regression Plot
plt.figure(figsize=(8, 6))
sns.regplot(x='MIDAS_Improvement', y='MSQ_Improvement', data=changes, ci=None, line_kws={"color":"red"})
plt.title('Regression: MIDAS Improvement Predicting MSQ Improvement')
plt.xlabel('MIDAS Improvement')
plt.ylabel('MSQ Improvement')
plt.grid(True, linestyle='--', alpha=0.7)
plt.show()

import pandas as pd
from scipy.stats import pearsonr, spearmanr, shapiro
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seaborn as sns

# Load the datasets
before_data = pd.read_csv('Before_Data.csv')
after_data = pd.read_csv('After_Data.csv')

# Calculate changes for correlation and regression analysis
changes = pd.DataFrame()
changes['Weight_Loss'] = before_data['Weight'] - after_data['Weight']
changes['BMI_Change'] = before_data['BMI'] - after_data['BMI']
changes['Migraine_Frequency_Change'] = before_data['Frequency'] - after_data['Frequency']
changes['Migraine_Severity_Change'] = before_data['Severity'] - after_data['Severity']
changes['MIDAS_Improvement'] = before_data['MIDAS'] - after_data['MIDAS']
changes['MSQ_Improvement'] = before_data['MSQ'] - after_data['MSQ']

# Visualization of Correlation and Regression
sns.set(style="whitegrid")

# Correlation Plots
plt.figure(figsize=(18, 6))

plt.subplot(1, 3, 1)
sns.scatterplot(x='Weight_Loss', y='Migraine_Frequency_Change', data=changes)
plt.title('Weight Loss vs Migraine Frequency Reduction')
plt.xlabel('Weight Loss (kg)')
plt.ylabel('Migraine Frequency Reduction')

plt.subplot(1, 3, 2)
sns.scatterplot(x='BMI_Change', y='MSQ_Improvement', data=changes)
plt.title('BMI Change vs MSQ Improvement')
plt.xlabel('BMI Change')
plt.ylabel('MSQ Improvement')

plt.subplot(1, 3, 3)
sns.scatterplot(x='MIDAS_Improvement', y='MSQ_Improvement', data=changes)
plt.title('MIDAS Improvement vs MSQ Improvement')
plt.xlabel('MIDAS Improvement')
plt.ylabel('MSQ Improvement')

plt.tight_layout()
plt.show()

# Regression Plot
plt.figure(figsize=(8, 6))
sns.regplot(x='MIDAS_Improvement', y='MSQ_Improvement', data=changes, ci=None, line_kws={"color":"red"})
plt.title('Regression: MIDAS Improvement Predicting MSQ Improvement')
plt.xlabel('MIDAS Improvement')
plt.ylabel('MSQ Improvement')
plt.grid(True, linestyle='--', alpha=0.7)
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Load the datasets
before_data = pd.read_csv('Before_Data.csv')
after_data = pd.read_csv('After_Data.csv')

# Calculate changes for correlation and regression analysis
changes = pd.DataFrame()
changes['Weight_Loss'] = before_data['Weight'] - after_data['Weight']
changes['BMI_Change'] = before_data['BMI'] - after_data['BMI']
changes['Migraine_Frequency_Change'] = before_data['Frequency'] - after_data['Frequency']
changes['Migraine_Severity_Change'] = before_data['Severity'] - after_data['Severity']
changes['MIDAS_Improvement'] = before_data['MIDAS'] - after_data['MIDAS']
changes['MSQ_Improvement'] = before_data['MSQ'] - after_data['MSQ']
changes['Age'] = before_data['Age']  # Assuming Age doesn't change after surgery

# Create Heatmap of Correlations
plt.figure(figsize=(10, 8))
correlation_matrix = changes.corr(method='spearman')

sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt='.2f', linewidths=0.5)
plt.title('Spearman Correlation Heatmap of Changes in Metrics Including Age')
plt.tight_layout()
plt.show()

import pandas as pd
from scipy.stats import ttest_ind, mannwhitneyu, shapiro
import matplotlib.pyplot as plt
import seaborn as sns

# Load the datasets
before_data = pd.read_csv('Before_Data.csv')
after_data = pd.read_csv('After_Data.csv')

# Calculate changes for gender analysis
changes = pd.DataFrame()
changes['Weight_Loss'] = before_data['Weight'] - after_data['Weight']
changes['BMI_Change'] = before_data['BMI'] - after_data['BMI']
changes['Migraine_Frequency_Change'] = before_data['Frequency'] - after_data['Frequency']
changes['Migraine_Severity_Change'] = before_data['Severity'] - after_data['Severity']
changes['MIDAS_Improvement'] = before_data['MIDAS'] - after_data['MIDAS']
changes['MSQ_Improvement'] = before_data['MSQ'] - after_data['MSQ']
changes['Gender'] = before_data['Gender']  # Assuming Gender column exists

# Split the data by gender
male_data = changes[changes['Gender'] == 'Male']
female_data = changes[changes['Gender'] == 'Female']

# Variables to analyze
metrics = ['Weight_Loss', 'BMI_Change', 'Migraine_Frequency_Change', 'Migraine_Severity_Change', 'MIDAS_Improvement', 'MSQ_Improvement']

# Store results
gender_comparison_results = {}

# Perform statistical tests
for metric in metrics:
    # Check for normality
    stat_male, p_male = shapiro(male_data[metric])
    stat_female, p_female = shapiro(female_data[metric])

    if p_male > 0.05 and p_female > 0.05:
        # If both groups are normally distributed, use t-test
        stat, p_value = ttest_ind(male_data[metric], female_data[metric])
        test_used = 'Independent t-test'
    else:
        # If not normally distributed, use Mann-Whitney U test
        stat, p_value = mannwhitneyu(male_data[metric], female_data[metric], alternative='two-sided')
        test_used = 'Mann-Whitney U test'

    # Save the results
    gender_comparison_results[metric] = {
        'Test': test_used,
        'p-value': round(p_value, 4),
        'Male Mean ± SD': f"{male_data[metric].mean():.2f} ± {male_data[metric].std():.2f}",
        'Female Mean ± SD': f"{female_data[metric].mean():.2f} ± {female_data[metric].std():.2f}"
    }

# Display the results
print("Gender Comparison Results:")
for metric, result in gender_comparison_results.items():
    print(f"{metric}: {result['Test']} | p-value = {result['p-value']} | Male: {result['Male Mean ± SD']} | Female: {result['Female Mean ± SD']}")

# Visualization
sns.set(style="whitegrid")
plt.figure(figsize=(18, 10))

for idx, metric in enumerate(metrics, 1):
    plt.subplot(2, 3, idx)
    sns.boxplot(x='Gender', y=metric, data=changes, palette='Set2')
    plt.title(f'{metric} by Gender')
    plt.ylabel(metric)

plt.tight_layout()
plt.show()

# Correct the column name to 'Sex' and re-run the analysis

# Load the datasets
before_data = pd.read_csv('/mnt/data/Before_Data.csv')
after_data = pd.read_csv('/mnt/data/After_Data.csv')

# Calculate changes for gender analysis
changes = pd.DataFrame()
changes['Weight_Loss'] = before_data['Weight'] - after_data['Weight']
changes['BMI_Change'] = before_data['BMI'] - after_data['BMI']
changes['Migraine_Frequency_Change'] = before_data['Frequency'] - after_data['Frequency']
changes['Migraine_Severity_Change'] = before_data['Severity'] - after_data['Severity']
changes['MIDAS_Improvement'] = before_data['MIDAS'] - after_data['MIDAS']
changes['MSQ_Improvement'] = before_data['MSQ'] - after_data['MSQ']
changes['Age'] = before_data['Age']  # Assuming Age doesn't change after surgery
changes['Sex'] = before_data['Sex']  # Corrected column name

# Split the data by gender
male_data = changes[changes['Sex'] == 'Male']
female_data = changes[changes['Sex'] == 'Female']

# Variables to analyze
metrics = ['Weight_Loss', 'BMI_Change', 'Migraine_Frequency_Change', 'Migraine_Severity_Change', 'MIDAS_Improvement', 'MSQ_Improvement']

# Store results
gender_comparison_results = {}

# Perform statistical tests
for metric in metrics:
    # Check for normality
    stat_male, p_male = shapiro(male_data[metric])
    stat_female, p_female = shapiro(female_data[metric])

    if p_male > 0.05 and p_female > 0.05:
        # If both groups are normally distributed, use t-test
        stat, p_value = ttest_ind(male_data[metric], female_data[metric])
        test_used = 'Independent t-test'
    else:
        # If not normally distributed, use Mann-Whitney U test
        stat, p_value = mannwhitneyu(male_data[metric], female_data[metric], alternative='two-sided')
        test_used = 'Mann-Whitney U test'

    # Save the results
    gender_comparison_results[metric] = {
        'Test': test_used,
        'p-value': round(p_value, 4),
        'Male Mean ± SD': f"{male_data[metric].mean():.2f} ± {male_data[metric].std():.2f}",
        'Female Mean ± SD': f"{female_data[metric].mean():.2f} ± {female_data[metric].std():.2f}"
    }

# Display the results
print("Gender Comparison Results:")
for metric, result in gender_comparison_results.items():
    print(f"{metric}: {result['Test']} | p-value = {result['p-value']} | Male: {result['Male Mean ± SD']} | Female: {result['Female Mean ± SD']}")

# Visualization
sns.set(style="whitegrid")
plt.figure(figsize=(18, 10))

for idx, metric in enumerate(metrics, 1):
    plt.subplot(2, 3, idx)
    sns.boxplot(x='Sex', y=metric, data=changes, palette='Set2')
    plt.title(f'{metric} by Gender')
    plt.ylabel(metric)

plt.tight_layout()
plt.show()

import pandas as pd
from scipy.stats import ttest_ind, mannwhitneyu, shapiro
import matplotlib.pyplot as plt
import seaborn as sns

# Load the datasets
before_data = pd.read_csv('Before_Data.csv')  # Make sure your path is correct
after_data = pd.read_csv('After_Data.csv')   # Make sure your path is correct

# Calculate changes for gender analysis
changes = pd.DataFrame()
changes['Weight_Loss'] = before_data['Weight'] - after_data['Weight']
changes['BMI_Change'] = before_data['BMI'] - after_data['BMI']
changes['Migraine_Frequency_Change'] = before_data['Frequency'] - after_data['Frequency']
changes['Migraine_Severity_Change'] = before_data['Severity'] - after_data['Severity']
changes['MIDAS_Improvement'] = before_data['MIDAS'] - after_data['MIDAS']
changes['MSQ_Improvement'] = before_data['MSQ'] - after_data['MSQ']
changes['Age'] = before_data['Age']  # Assuming Age doesn't change after surgery
changes['Sex'] = before_data['Sex']  # Corrected column name for Gender

# Split the data by gender
male_data = changes[changes['Sex'] == 'Male']
female_data = changes[changes['Sex'] == 'Female']

# Variables to analyze
metrics = ['Weight_Loss', 'BMI_Change', 'Migraine_Frequency_Change', 'Migraine_Severity_Change', 'MIDAS_Improvement', 'MSQ_Improvement']

# Store results
gender_comparison_results = {}

# Perform statistical tests
for metric in metrics:
    # Check for normality
    stat_male, p_male = shapiro(male_data[metric])
    stat_female, p_female = shapiro(female_data[metric])

    if p_male > 0.05 and p_female > 0.05:
        # If both groups are normally distributed, use t-test
        stat, p_value = ttest_ind(male_data[metric], female_data[metric])
        test_used = 'Independent t-test'
    else:
        # If not normally distributed, use Mann-Whitney U test
        stat, p_value = mannwhitneyu(male_data[metric], female_data[metric], alternative='two-sided')
        test_used = 'Mann-Whitney U test'

    # Save the results
    gender_comparison_results[metric] = {
        'Test': test_used,
        'p-value': round(p_value, 4),
        'Male Mean ± SD': f"{male_data[metric].mean():.2f} ± {male_data[metric].std():.2f}",
        'Female Mean ± SD': f"{female_data[metric].mean():.2f} ± {female_data[metric].std():.2f}"
    }

# Display the results
print("Gender Comparison Results:")
for metric, result in gender_comparison_results.items():
    print(f"{metric}: {result['Test']} | p-value = {result['p-value']} | Male: {result['Male Mean ± SD']} | Female: {result['Female Mean ± SD']}")

# Visualization
sns.set(style="whitegrid")
plt.figure(figsize=(18, 10))

for idx, metric in enumerate(metrics, 1):
    plt.subplot(2, 3, idx)
    sns.boxplot(x='Sex', y=metric, data=changes, palette='Set2')
    plt.title(f'{metric} by Gender')
    plt.ylabel(metric)

plt.tight_layout()
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

# Set the style for better visualization
sns.set(style="whitegrid")

# Create a figure to hold all plots
plt.figure(figsize=(18, 12))

# 1. Violin Plots - Show distribution and density
plt.subplot(2, 2, 1)
sns.violinplot(x='Sex', y='Weight_Loss', data=changes, palette='Set2')
plt.title('Weight Loss by Gender')

plt.subplot(2, 2, 2)
sns.violinplot(x='Sex', y='BMI_Change', data=changes, palette='Set2')
plt.title('BMI Change by Gender')

plt.subplot(2, 2, 3)
sns.violinplot(x='Sex', y='Migraine_Frequency_Change', data=changes, palette='Set2')
plt.title('Migraine Frequency Reduction by Gender')

plt.subplot(2, 2, 4)
sns.violinplot(x='Sex', y='Migraine_Severity_Change', data=changes, palette='Set2')
plt.title('Migraine Severity Reduction by Gender')

# 2. Bar Plots with Error Bars - Show mean with standard deviation
plt.figure(figsize=(12, 8))
plt.subplot(1, 2, 1)
sns.barplot(x='Sex', y='Weight_Loss', data=changes, ci="sd", palette='Set2')
plt.title('Weight Loss Comparison by Gender')

plt.subplot(1, 2, 2)
sns.barplot(x='Sex', y='BMI_Change', data=changes, ci="sd", palette='Set2')
plt.title('BMI Change Comparison by Gender')

# 3. Side-by-Side Histograms - Visualize distributions for each gender
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
sns.histplot(male_data['Weight_Loss'], color='blue', kde=True, label='Male', stat="density", bins=15)
sns.histplot(female_data['Weight_Loss'], color='red', kde=True, label='Female', stat="density", bins=15)
plt.legend()
plt.title('Weight Loss Distribution by Gender')

plt.subplot(1, 2, 2)
sns.histplot(male_data['BMI_Change'], color='blue', kde=True, label='Male', stat="density", bins=15)
sns.histplot(female_data['BMI_Change'], color='red', kde=True, label='Female', stat="density", bins=15)
plt.legend()
plt.title('BMI Change Distribution by Gender')

plt.tight_layout()
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

# Sample female data to match the number of males for balanced visualization (if data is imbalanced)
min_sample_size = min(len(male_data), len(female_data))
male_sample = male_data.sample(min_sample_size, random_state=42)
female_sample = female_data.sample(min_sample_size, random_state=42)

# Combine the balanced data
balanced_data = pd.concat([male_sample, female_sample])

# Set the style for better visualization
sns.set(style="whitegrid")

# Create a figure to hold all plots
plt.figure(figsize=(18, 12))

# 1. Violin Plots - Show distribution and density
plt.subplot(2, 2, 1)
sns.violinplot(x='Sex', y='Weight_Loss', data=balanced_data, palette='Set2')
plt.title('Weight Loss by Gender')

plt.subplot(2, 2, 2)
sns.violinplot(x='Sex', y='BMI_Change', data=balanced_data, palette='Set2')
plt.title('BMI Change by Gender')

plt.subplot(2, 2, 3)
sns.violinplot(x='Sex', y='Migraine_Frequency_Change', data=balanced_data, palette='Set2')
plt.title('Migraine Frequency Reduction by Gender')

plt.subplot(2, 2, 4)
sns.violinplot(x='Sex', y='Migraine_Severity_Change', data=balanced_data, palette='Set2')
plt.title('Migraine Severity Reduction by Gender')

# 2. Bar Plots with Error Bars - Show mean with standard deviation
plt.figure(figsize=(12, 8))
plt.subplot(1, 2, 1)
sns.barplot(x='Sex', y='Weight_Loss', data=balanced_data, ci="sd", palette='Set2')
plt.title('Weight Loss Comparison by Gender')

plt.subplot(1, 2, 2)
sns.barplot(x='Sex', y='BMI_Change', data=balanced_data, ci="sd", palette='Set2')
plt.title('BMI Change Comparison by Gender')

# 3. Side-by-Side Histograms - Visualize distributions for each gender
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
sns.histplot(male_sample['Weight_Loss'], color='blue', kde=True, label='Male', stat="density", bins=15)
sns.histplot(female_sample['Weight_Loss'], color='red', kde=True, label='Female', stat="density", bins=15)
plt.legend()
plt.title('Weight Loss Distribution by Gender')

plt.subplot(1, 2, 2)
sns.histplot(male_sample['BMI_Change'], color='blue', kde=True, label='Male', stat="density", bins=15)
sns.histplot(female_sample['BMI_Change'], color='red', kde=True, label='Female', stat="density", bins=15)
plt.legend()
plt.title('BMI Change Distribution by Gender')

plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Create a figure to hold the plot
plt.figure(figsize=(10, 6))

# Plot the MIDAS stage comparison before and after surgery as a stacked bar chart
midas_stage_comparison.plot(kind='bar', stacked=True, color=['lightblue', 'lightgreen', 'orange', 'red'], ax=plt.gca())
plt.title('MIDAS Stage Comparison Before and After Surgery')
plt.xlabel('Timepoint')
plt.ylabel('Number of Patients')
plt.xticks(rotation=0)
plt.tight_layout()

# Show the plot
plt.show()

import matplotlib.pyplot as plt

# Grouping the data by Timepoint and MIDAS Stage, and counting the number of patients in each stage
midas_stage_comparison = combined_data.groupby(['Timepoint', 'MIDAS_Stage']).size().unstack(fill_value=0)

# Re-plot the comparison with "Before Surgery" on the left and "After Surgery" on the right
plt.figure(figsize=(10, 6))
midas_stage_comparison.plot(kind='bar', stacked=True, color=['lightblue', 'lightgreen', 'orange', 'red'], ax=plt.gca())
plt.title('MIDAS Stage Comparison Before and After Surgery')
plt.xlabel('MIDAS Stages')
plt.ylabel('Number of Patients')
plt.xticks(rotation=0)
plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Apply the MIDAS Staging function to the 'before' and 'after' data
before_data['MIDAS_Stage'] = before_data['MIDAS'].apply(get_midas_stage)
after_data['MIDAS_Stage'] = after_data['MIDAS'].apply(get_midas_stage)

# Add a 'Timepoint' column to distinguish between before and after surgery
before_data['Timepoint'] = 'Before Surgery'
after_data['Timepoint'] = 'After Surgery'

# Combine both before and after data
combined_data = pd.concat([before_data[['MIDAS', 'MIDAS_Stage', 'Timepoint']],
                           after_data[['MIDAS', 'MIDAS_Stage', 'Timepoint']]])

# Group by 'Timepoint' and 'MIDAS_Stage' and count the number of patients in each stage
midas_stage_comparison = combined_data.groupby(['Timepoint', 'MIDAS_Stage']).size().unstack(fill_value=0)

# Plot the comparison with "Before Surgery" on the left and "After Surgery" on the right
plt.figure(figsize=(10, 6))
midas_stage_comparison.plot(kind='bar', stacked=True, color=['lightblue', 'lightgreen', 'orange', 'red'], ax=plt.gca())
plt.title('MIDAS Stage Comparison Before and After Surgery')
plt.xlabel('MIDAS Stages')
plt.ylabel('Number of Patients')
plt.xticks(rotation=0)
plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Define the MIDAS stage function based on the MIDAS score
def get_midas_stage(midas_score):
    if midas_score <= 5:
        return 'Stage I (Minimal Disability)'
    elif 6 <= midas_score <= 10:
        return 'Stage II (Mild Disability)'
    elif 11 <= midas_score <= 20:
        return 'Stage III (Moderate Disability)'
    else:
        return 'Stage IV (Severe Disability)'

# Apply the MIDAS Staging function to the 'before' and 'after' data
before_data['MIDAS_Stage'] = before_data['MIDAS'].apply(get_midas_stage)
after_data['MIDAS_Stage'] = after_data['MIDAS'].apply(get_midas_stage)

# Add a 'Timepoint' column to distinguish between before and after surgery
before_data['Timepoint'] = 'Before Surgery'
after_data['Timepoint'] = 'After Surgery'

# Combine both before and after data
combined_data = pd.concat([before_data[['MIDAS', 'MIDAS_Stage', 'Timepoint']],
                           after_data[['MIDAS', 'MIDAS_Stage', 'Timepoint']]])

# Group by 'Timepoint' and 'MIDAS_Stage' and count the number of patients in each stage
midas_stage_comparison = combined_data.groupby(['Timepoint', 'MIDAS_Stage']).size().unstack(fill_value=0)

# Plot the comparison with "Before Surgery" on the left and "After Surgery" on the right
plt.figure(figsize=(10, 6))
midas_stage_comparison.plot(kind='bar', stacked=True, color=['lightblue', 'lightgreen', 'orange', 'red'], ax=plt.gca())
plt.title('MIDAS Stage Comparison Before and After Surgery')
plt.xlabel('MIDAS Stages')
plt.ylabel('Number of Patients')
plt.xticks(rotation=0)
plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Define the MIDAS stage function based on the MIDAS score
def get_midas_stage(midas_score):
    if midas_score <= 5:
        return 'Stage I (Minimal Disability)'
    elif 6 <= midas_score <= 10:
        return 'Stage II (Mild Disability)'
    elif 11 <= midas_score <= 20:
        return 'Stage III (Moderate Disability)'
    else:
        return 'Stage IV (Severe Disability)'

# Apply the MIDAS Staging function to the 'before' and 'after' data
before_data['MIDAS_Stage'] = before_data['MIDAS'].apply(get_midas_stage)
after_data['MIDAS_Stage'] = after_data['MIDAS'].apply(get_midas_stage)

# Add a 'Timepoint' column to distinguish between before and after surgery
before_data['Timepoint'] = 'Before Surgery'
after_data['Timepoint'] = 'After Surgery'

# Combine both before and after data
combined_data = pd.concat([before_data[['MIDAS', 'MIDAS_Stage', 'Timepoint']],
                           after_data[['MIDAS', 'MIDAS_Stage', 'Timepoint']]])

# Group by 'Timepoint' and 'MIDAS_Stage' and count the number of patients in each stage
midas_stage_comparison = combined_data.groupby(['Timepoint', 'MIDAS_Stage']).size().unstack(fill_value=0)

# Plot the comparison with "Before Surgery" on the left and "After Surgery" on the right
plt.figure(figsize=(10, 6))
midas_stage_comparison.plot(kind='bar', stacked=True, color=['lightblue', 'lightgreen', 'orange', 'red'], ax=plt.gca())
plt.title('MIDAS Stage Comparison Before and After Surgery')
plt.xlabel('MIDAS Stages')
plt.ylabel('Number of Patients')
plt.xticks(rotation=0)
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Group the data by Timepoint and MIDAS Stage, and count the number of patients in each stage
midas_stage_comparison = combined_data.groupby(['Timepoint', 'MIDAS_Stage']).size().unstack(fill_value=0)

# Re-plot the comparison with "Before Surgery" on the left and "After Surgery" on the right
midas_stage_comparison = midas_stage_comparison[['After Surgery', 'Before Surgery']]  # Reversing the order

plt.figure(figsize=(10, 6))
midas_stage_comparison.plot(kind='bar', stacked=True, color=['lightblue', 'lightgreen', 'orange', 'red'], ax=plt.gca())
plt.title('MIDAS Stage Comparison Before and After Surgery')
plt.xlabel('MIDAS Stages')
plt.ylabel('Number of Patients')
plt.xticks(rotation=0)
plt.tight_layout()
plt.show()